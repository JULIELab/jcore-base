package de.julielab.jcore.utility.index;

import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.function.Supplier;
import java.util.stream.Stream;

import org.apache.uima.cas.FSIterator;
import org.apache.uima.cas.Type;
import org.apache.uima.jcas.JCas;
import org.apache.uima.jcas.tcas.Annotation;

/**
 * <p>
 * This class builds a map from arbitrary keys to collections of annotations.
 * For convenience access, class takes suppliers for the generation of index or
 * search terms as well as suppliers for the actual collection implementations
 * that should be used within the index and for search results. Thus, it's just
 * a kind of convenience framework around a map.
 * </p>
 * 
 * @author faessler
 *
 * @param <T>
 *            The annotation type the index is over.
 * @param <K>
 *            The key type used to index the annotations.
 * @param <C>
 *            The collection type (e.g. ArrayList<Token>) used to store
 *            annotations in the index.
 * @param <U>
 *            The collection type (e.g. TreeSet<Sentence>) used to return search
 *            results.
 */
public class JCoReMapAnnotationIndex<T extends Annotation, K extends Comparable<K>, C extends Collection<T>, U extends Collection<T>> {

	private final Map<K, C> index;
	private final IndexTermGenerator<K> indexTermGenerator;
	private final IndexTermGenerator<K> searchTermGenerator;
	private final Supplier<U> resultCollectionSupplier;
	private Supplier<C> indexAnnotationCollectionSupplier;
	private U emptyResultCollection;

	/**
	 * 
	 * @param indexTermGenerator
	 *            Generates index terms of generic parameter type K. Those index
	 *            terms will be extracted from indexed annotations.
	 * @param searchTermGenerator
	 *            Generates search terms of generic parameter K. The index will
	 *            extract all {@link IndexEntry} items in the index matching one
	 *            of the generated terms. This may be the very same term
	 *            generator passed for indexTermGenerator.
	 * @param indexAnnotationCollectionSupplier
	 *            A supplier for the collection data structure used to store
	 *            annotations in the index. In case of single index hits during
	 *            a search, this data structure is returned directly to save
	 *            time, if it is compatible with the return type specified by
	 *            the generic type parameter U (search result return type). This
	 *            way the desired output structure can be specified (e.g. a
	 *            TreeSet with a specific comparator).
	 * @param resultCollectionSupplier
	 *            In case a multiple search terms for a search as generated by
	 *            searchTermGenerator, not the index annotation collection is
	 *            returned but this supplier is used to create a new collection
	 *            to return search results for all search terms. Thus, when it
	 *            is expected that searchTermGenerator will often generate
	 *            multiple search terms, the indexAnnotationCollectionSupplier
	 *            should create a collection efficient for adding and iterating
	 *            and the resultCollectionSupplier should create a collection
	 *            reflects the desired output format.
	 */
	public JCoReMapAnnotationIndex(Supplier<Map<K, C>> indexSupplier, IndexTermGenerator<K> indexTermGenerator,
			IndexTermGenerator<K> searchTermGenerator, Supplier<C> indexAnnotationCollectionSupplier,
			Supplier<U> resultCollectionSupplier) {
		this.indexTermGenerator = indexTermGenerator;
		this.searchTermGenerator = searchTermGenerator;
		this.indexAnnotationCollectionSupplier = indexAnnotationCollectionSupplier;
		this.resultCollectionSupplier = resultCollectionSupplier;
		this.index = indexSupplier.get();
		emptyResultCollection = resultCollectionSupplier.get();
	}

	/**
	 * Indexes the whole contents of the CAS annotation index of type
	 * <tt>type</tt>. For each annotation, the {@link #indexTermGenerator} is
	 * used to create terms with which the annotation will be associated in the
	 * index and can be retrieved by a <code>search</code> method.
	 * 
	 * @param jCas
	 *            A CAS instance.
	 * @param type
	 *            The annotation type to index.
	 */
	public void index(JCas jCas, int type) {
		index(jCas, jCas.getCasType(type));
	}

	/**
	 * Indexes the whole contents of the CAS annotation index of type
	 * <tt>type</tt>. For each annotation, the {@link #indexTermGenerator} is
	 * used to create terms with which the annotation will be associated in the
	 * index and can be retrieved by a <code>search</code> method.
	 * 
	 * @param jCas
	 *            A CAS instance.
	 * @param type
	 *            The annotation type to index.
	 */
	@SuppressWarnings("unchecked")
	public void index(JCas jCas, Type type) {
		FSIterator<Annotation> it = jCas.getAnnotationIndex(type).iterator();
		while (it.hasNext()) {
			Annotation annotation = (Annotation) it.next();
			index((T) annotation);
		}
	}

	/**
	 * Indexes the annotation <tt>a</tt>. The {@link #indexTermGenerator} is
	 * used to create terms with which the annotation will be associated in the
	 * index and can be retrieved by a <code>search</code> method.
	 * 
	 * @param a
	 *            The annotation to index.
	 */
	public void index(T a) {
		Stream<K> indexTerms = indexTermGenerator.generateIndexTerms(a);
		indexTerms.forEach(t -> {
			C annotations = index.get(t);
			if (annotations == null) {
				annotations = indexAnnotationCollectionSupplier.get();
				index.put(t, annotations);
			}
			annotations.add(a);
		});
	}

	/**
	 * <p>
	 * Generates search terms from <tt>a</tt> via the
	 * {@link #searchTermGenerator}. These terms are then used to lookup
	 * annotations in the index and returned.
	 * </p>
	 * <p>
	 * It is perfectly valid and actually a frequent usecase to search for
	 * annotations which are not themselves part of the index. When searching,
	 * for example, for (parts of) the covered text, one can search for an
	 * entity and retrieve tokens matching the entity's name.
	 * </p>
	 * 
	 * @param a
	 *            The annotation that provides search terms to search for.
	 * @return The found annotations.
	 */
	public U search(Annotation a) {
		Stream<K> searchTerms = searchTermGenerator.generateIndexTerms(a);
		return search(searchTerms);
	}

	/**
	 * Searches for the provided search terms in the index.
	 * 
	 * @param searchTerms
	 *            The terms used to look up annotations.
	 * @return The found annotations.
	 */
	@SuppressWarnings("unchecked")
	public U search(Stream<K> searchTerms) {
		U hits = emptyResultCollection;
		int i = 0;
		for (Iterator<K> it = searchTerms.iterator(); it.hasNext();) {
			K t = it.next();
			C hit = index.get(t);
			if (hit != null) {
				if (i == 0 && hit.getClass().equals(emptyResultCollection.getClass())) {
					hits = (U) hit;
				} else if (i == 1 && hit.getClass().equals(emptyResultCollection.getClass())) {
					U previousHits = hits;
					hits = resultCollectionSupplier.get();
					hits.addAll(previousHits);
					hits.addAll(hit);
				} else {
					hits.addAll(hit);
				}
				++i;
			}
		}

		return hits;
	}

	/**
	 * Searches for annotations in the index by the provided search term.
	 * 
	 * @param searchTerm
	 *            The term to search for.
	 * @return The found annotations.
	 */
	@SuppressWarnings("unchecked")
	public U search(K searchTerm) {
		U hits = emptyResultCollection;
		C hit = index.get(searchTerm);
		if (hit != null) {
			if (hit.getClass().equals(emptyResultCollection.getClass()))
				hits = (U) hit;
			else {
				hits = resultCollectionSupplier.get();
				hits.addAll(hit);
			}
		}

		return hits;
	}

	/**
	 * <p>
	 * An interface that defines a way to construct index or search terms from
	 * an annotation <tt>a</tt>. Implementations are given to the constructor of
	 * {@link JCoReMapAnnotationIndex} and are then internally used to create index
	 * terms from annotations.
	 * </p>
	 * <p>
	 * The class {@link TermGenerators} offers a range of predefined term
	 * generators.
	 * </p>
	 * 
	 * @author faessler
	 *
	 * @param <K>
	 *            The type of index terms that should be created for an
	 *            annotation, for example a String or an Integer. This type is
	 *            also used by the index map for the keys, where the generated
	 *            index terms will go to.
	 */
	@FunctionalInterface
	public interface IndexTermGenerator<K extends Comparable<K>> {
		public Stream<K> generateIndexTerms(Annotation a);
	}

}
