package de.julielab.jcore.utility;

import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Map;
import java.util.function.Supplier;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import org.apache.uima.cas.FSIterator;
import org.apache.uima.cas.Type;
import org.apache.uima.jcas.JCas;
import org.apache.uima.jcas.tcas.Annotation;

/**
 * <p>
 * This class builds a map from arbitrary keys to collections of annotations.
 * For convenience access, class takes suppliers for the generation of index or
 * search terms as well as suppliers for the actual collection implementations
 * that should be used within the index and for search results. Thus, it's just
 * a kind of convenience framework around a map.
 * </p>
 * 
 * @author faessler
 *
 * @param <T>
 *            The annotation type the index is over.
 * @param <K>
 *            The key type used to index the annotations.
 * @param <C>
 *            The collection type (e.g. ArrayList<Token>) used to store
 *            annotations in the index.
 * @param <U>
 *            The collection type (e.g. TreeSet<Sentence>) used to return search
 *            results.
 */
public class JCoReAnnotationIndex<T extends Annotation, K extends Comparable<K>, C extends Collection<T>, U extends Collection<T>> {

	private final Map<K, C> index;
	private final IndexTermGenerator<K> indexTermGenerator;
	private final IndexTermGenerator<K> searchTermGenerator;
	private final Supplier<U> resultCollectionSupplier;
	private Supplier<C> indexAnnotationCollectionSupplier;
	private U emptyResultCollection;

	/**
	 * 
	 * @param indexTermGenerator
	 *            Generates index terms of generic parameter type K. Those index
	 *            terms will be extracted from indexed annotations.
	 * @param searchTermGenerator
	 *            Generates search terms of generic parameter K. The index will
	 *            extract all {@link IndexEntry} items in the index matching one
	 *            of the generated terms. This may be the very same term
	 *            generator passed for indexTermGenerator.
	 * @param indexAnnotationCollectionSupplier
	 *            A supplier for the collection data structure used to store
	 *            annotations in the index. In case of single index hits during
	 *            a search, this data structure is returned directly to save
	 *            time, if it is compatible with the return type specified by
	 *            the generic type parameter U (search result return type). This
	 *            way the desired output structure can be specified (e.g. a
	 *            TreeSet with a specific comparator).
	 * @param resultCollectionSupplier
	 *            In case a multiple search terms for a search as generated by
	 *            searchTermGenerator, not the index annotation collection is
	 *            returned but this supplier is used to create a new collection
	 *            to return search results for all search terms. Thus, when it
	 *            is expected that searchTermGenerator will often generate
	 *            multiple search terms, the indexAnnotationCollectionSupplier
	 *            should create a collection efficient for adding and iterating
	 *            and the resultCollectionSupplier should create a collection
	 *            reflects the desired output format.
	 */
	public JCoReAnnotationIndex(Supplier<Map<K, C>> indexSupplier, IndexTermGenerator<K> indexTermGenerator,
			IndexTermGenerator<K> searchTermGenerator, Supplier<C> indexAnnotationCollectionSupplier,
			Supplier<U> resultCollectionSupplier) {
		this.indexTermGenerator = indexTermGenerator;
		this.searchTermGenerator = searchTermGenerator;
		this.indexAnnotationCollectionSupplier = indexAnnotationCollectionSupplier;
		this.resultCollectionSupplier = resultCollectionSupplier;
		this.index = indexSupplier.get();
		emptyResultCollection = resultCollectionSupplier.get();
	}

	/**
	 * Indexes the whole contents of the CAS annotation index of type
	 * <tt>type</tt>. For each annotation, the {@link #indexTermGenerator} is
	 * used to create terms with which the annotation will be associated in the
	 * index and can be retrieved by a <code>search</code> method.
	 * 
	 * @param jCas
	 *            A CAS instance.
	 * @param type
	 *            The annotation type to index.
	 */
	public void index(JCas jCas, int type) {
		index(jCas, jCas.getCasType(type));
	}

	/**
	 * Indexes the whole contents of the CAS annotation index of type
	 * <tt>type</tt>. For each annotation, the {@link #indexTermGenerator} is
	 * used to create terms with which the annotation will be associated in the
	 * index and can be retrieved by a <code>search</code> method.
	 * 
	 * @param jCas
	 *            A CAS instance.
	 * @param type
	 *            The annotation type to index.
	 */
	@SuppressWarnings("unchecked")
	public void index(JCas jCas, Type type) {
		FSIterator<Annotation> it = jCas.getAnnotationIndex(type).iterator();
		while (it.hasNext()) {
			Annotation annotation = (Annotation) it.next();
			index((T) annotation);
		}
	}

	/**
	 * Indexes the annotation <tt>a</tt>. The {@link #indexTermGenerator} is
	 * used to create terms with which the annotation will be associated in the
	 * index and can be retrieved by a <code>search</code> method.
	 * 
	 * @param a
	 *            The annotation to index.
	 */
	public void index(T a) {
		Stream<K> indexTerms = indexTermGenerator.generateIndexTerms(a);
		indexTerms.forEach(t -> {
			C annotations = index.get(t);
			if (annotations == null) {
				annotations = indexAnnotationCollectionSupplier.get();
				index.put(t, annotations);
			}
			annotations.add(a);
		});
	}

	/**
	 * <p>
	 * Generates search terms from <tt>a</tt> via the
	 * {@link #searchTermGenerator}. These terms are then used to lookup
	 * annotations in the index and returned.
	 * </p>
	 * <p>
	 * It is perfectly valid and actually a frequent usecase to search for
	 * annotations which are not themselves part of the index. When searching,
	 * for example, for (parts of) the covered text, one can search for an
	 * entity and retrieve tokens matching the entity's name.
	 * </p>
	 * 
	 * @param a
	 *            The annotation that provides search terms to search for.
	 * @return The found annotations.
	 */
	public U search(Annotation a) {
		Stream<K> searchTerms = searchTermGenerator.generateIndexTerms(a);
		return search(searchTerms);
	}

	/**
	 * Searches for the provided search terms in the index.
	 * 
	 * @param searchTerms
	 *            The terms used to look up annotations.
	 * @return The found annotations.
	 */
	@SuppressWarnings("unchecked")
	public U search(Stream<K> searchTerms) {
		U hits = emptyResultCollection;
		int i = 0;
		for (Iterator<K> it = searchTerms.iterator(); it.hasNext();) {
			K t = it.next();
			C hit = index.get(t);
			if (hit != null) {
				if (i == 0 && hit.getClass().equals(emptyResultCollection.getClass())) {
					hits = (U) hit;
				} else if (i == 1 && hit.getClass().equals(emptyResultCollection.getClass())) {
					U previousHits = hits;
					hits = resultCollectionSupplier.get();
					hits.addAll(previousHits);
					hits.addAll(hit);
				} else {
					hits.addAll(hit);
				}
				++i;
			}
		}

		return hits;
	}

	/**
	 * Searches for annotations in the index by the provided search term.
	 * 
	 * @param searchTerm
	 *            The term to search for.
	 * @return The found annotations.
	 */
	@SuppressWarnings("unchecked")
	public U search(K searchTerm) {
		U hits = emptyResultCollection;
		C hit = index.get(searchTerm);
		if (hit != null) {
			if (hit.getClass().equals(emptyResultCollection.getClass()))
				hits = (U) hit;
			else {
				hits = resultCollectionSupplier.get();
				hits.addAll(hit);
			}
		}

		return hits;
	}

	/**
	 * <p>
	 * An interface that defines a way to construct index or search terms from
	 * an annotation <tt>a</tt>. Implementations are given to the constructor of
	 * {@link JCoReAnnotationIndex} and are then internally used to create index
	 * terms from annotations.
	 * </p>
	 * <p>
	 * The class {@link TermGenerators} offers a range of predefined term
	 * generators.
	 * </p>
	 * 
	 * @author faessler
	 *
	 * @param <K>
	 *            The type of index terms that should be created for an
	 *            annotation, for example a String or an Integer. This type is
	 *            also used by the index map for the keys, where the generated
	 *            index terms will go to.
	 */
	@FunctionalInterface
	public interface IndexTermGenerator<K extends Comparable<K>> {
		public Stream<K> generateIndexTerms(Annotation a);
	}

	/**
	 * This class offers some commonly used comparators on annotations.
	 * 
	 * @author faessler
	 *
	 */
	public static class Comparators {
		/**
		 * Compares annotations strictly by their offsets. Two annotations are
		 * equal if both begin and end offsets are equal. If not, they are
		 * sorted by begin offset or, when those are equal, be end offset.
		 * 
		 * @return The comparison value.
		 */
		public <T extends Annotation> Comparator<T> exactOffsetMatchComparator() {
			return (o1, o2) -> {

				if (o1.getBegin() == o2.getBegin() && o1.getEnd() == o2.getEnd())
					return 0;
				if (o1.getBegin() == o2.getBegin())
					return o1.getEnd() - o2.getEnd();
				return o1.getBegin() - o2.getBegin();
			};
		}

		/**
		 * Compares annotations for any kind of overlapping. As long as two
		 * annotations overlap for at least a single position, they are deemed
		 * "equal" by this comparator. Otherwise, they are sorted by begin
		 * offset.
		 * 
		 * @return 0 if annotations overlap, the start offset difference
		 *         otherwise.
		 */
		public <T extends Annotation> Comparator<T> overlapComparator() {
			return (o1, o2) -> {
				int b1 = o1.getBegin();
				int e1 = o1.getEnd();
				int b2 = o2.getBegin();
				int e2 = o2.getEnd();

				if ((b1 <= b2) && (e1 >= e2)) {
					return 0;
				} else if ((b1 >= b2) && (e1 <= e2)) {
					return 0;
				} else if ((b1 < e2) && (e1 > e2)) {
					return 0;
				} else if ((b1 < b2) && (e1 > b2)) {
					return 0;
				}
				return b1 - b2;
			};
		}
	}

	/**
	 * This class offers a range of predefined term generators (to be used as a
	 * constructor argument to {@link JCoReAnnotationIndex} that might be useful
	 * in a range of applications.
	 * 
	 * @author faessler
	 *
	 */
	public static class TermGenerators {
		/**
		 * Creates strict n-grams of the covered text of an annotation. Returned
		 * terms are always of length n. Annotations shorter than n will not
		 * return any terms.
		 * 
		 * @param n
		 *            The n-gram size.
		 * @return The n-gram index terms.
		 */
		public static IndexTermGenerator<String> nGramTermGenerator(int n) {
			return a -> {
				String text = a.getCoveredText();
				return IntStream.range(0, text.length()).mapToObj(i -> {
					if (i + n <= text.length())
						return text.substring(i, i + n);
					return null;
				}).filter(s -> s != null);
			};
		}

		/**
		 * Generates as a search term the prefix of the covered text of an
		 * annotation of length <tt>length</tt>. If the annotation is shorter
		 * than <tt>length</tt> no terms are generated.
		 * 
		 * @param length
		 *            The prefix length.
		 * @return The annotation text prefix of length <tt>length</tt>
		 */
		public static IndexTermGenerator<String> prefixTermGenerator(int length) {
			return a -> {
				String text = a.getCoveredText();
				if (text.length() >= length)
					return Stream.of(text.substring(0, length));
				return Stream.empty();
			};
		}

		/**
		 * Generates as a search term the suffix of the covered text of an
		 * annotation of length <tt>length</tt>. If the annotation is shorter
		 * than <tt>length</tt> no terms are generated.
		 * 
		 * @param length
		 *            The suffix length.
		 * @return The annotation text suffix of length <tt>length</tt>
		 */
		public static IndexTermGenerator<String> suffixTermGenerator(int length) {
			return a -> {
				String text = a.getCoveredText();
				if (text.length() >= length)
					return Stream.of(text.substring(text.length() - length, text.length()));
				return Stream.empty();
			};
		}
	}

}
