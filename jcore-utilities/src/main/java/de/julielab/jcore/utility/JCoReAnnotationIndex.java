package de.julielab.jcore.utility;

import java.util.Collection;
import java.util.Comparator;
import java.util.Iterator;
import java.util.TreeSet;
import java.util.function.Supplier;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import org.apache.uima.cas.FSIterator;
import org.apache.uima.cas.Type;
import org.apache.uima.jcas.JCas;
import org.apache.uima.jcas.tcas.Annotation;

/**
 * <p>
 * This class is meant to organize a large set of annotations indexed by some
 * arbitrary key so that a lookup on a specific key provides an efficient access
 * method to annotations associated with it.
 * </p>
 * <p>
 * This class builds a TreeSet of {@link IndexEntry} instances. Each index entry
 * consists of a key and a set of annotations indexed by this key. Methods for
 * indexing and searching provide convenience access points to the index
 * structure.
 * </p>
 * <p>
 * For annotat
 * </p>
 * 
 * @author faessler
 *
 * @param <T>
 *            The annotation type the index is over.
 * @param <K>
 *            The key type used to index the annotations.
 * @param <C>
 *            The collection type (e.g. ArrayList<Token>) used to store
 *            annotations in the index.
 * @param <U>
 *            The collection type (e.g. TreeSet<Sentence>) used to return search
 *            results.
 */
public class JCoReAnnotationIndex<T extends Annotation, K extends Comparable<K>, C extends Collection<T>, U extends Collection<T>> {

	private final TreeSet<IndexEntry<T, K>> index;
	private final IndexTermGenerator<K> indexTermGenerator;
	private final IndexTermGenerator<K> searchTermGenerator;
	private final Supplier<U> resultCollectionSupplier;
	private Supplier<C> indexAnnotationCollectionSupplier;
	private U emptyResultCollection;

	/**
	 * 
	 * @param indexTermGenerator
	 *            Generates index terms of generic parameter type K. Those index
	 *            terms will be extracted from indexed annotations.
	 * @param searchTermGenerator
	 *            Generates search terms of generic parameter K. The index will
	 *            extract all {@link IndexEntry} items in the index matching one
	 *            of the generated terms. This may be the very same term
	 *            generator passed for indexTermGenerator.
	 * @param indexAnnotationCollectionSupplier
	 *            A supplier for the collection data structure used to store
	 *            annotations in the index. In case of single index hits during
	 *            a search, this data structure is returned directly to save
	 *            time, if it is compatible with the return type specified by
	 *            the generic type parameter U (search result return type). This
	 *            way the desired output structure can be specified (e.g. a
	 *            TreeSet with a specific comparator).
	 * @param resultCollectionSupplier
	 *            In case a multiple search terms for a search as generated by
	 *            searchTermGenerator, not the index annotation collection is
	 *            returned but this supplier is used to create a new collection
	 *            to return search results for all search terms. Thus, when it
	 *            is expected that searchTermGenerator will often generate
	 *            multiple search terms, the indexAnnotationCollectionSupplier
	 *            should create a collection efficient for adding and iterating
	 *            and the resultCollectionSupplier should create a collection
	 *            reflects the desired output format.
	 */
	public JCoReAnnotationIndex(IndexTermGenerator<K> indexTermGenerator, IndexTermGenerator<K> searchTermGenerator,
			Supplier<C> indexAnnotationCollectionSupplier, Supplier<U> resultCollectionSupplier) {
		this.indexTermGenerator = indexTermGenerator;
		this.searchTermGenerator = searchTermGenerator;
		this.indexAnnotationCollectionSupplier = indexAnnotationCollectionSupplier;
		this.resultCollectionSupplier = resultCollectionSupplier;
		this.index = new TreeSet<>();
		emptyResultCollection = resultCollectionSupplier.get();
	}

	public void index(JCas jCas, int type) {
		index(jCas, jCas.getCasType(type));
	}

	@SuppressWarnings("unchecked")
	public void index(JCas jCas, Type type) {
		FSIterator<Annotation> it = jCas.getAnnotationIndex(type).iterator();
		while (it.hasNext()) {
			Annotation annotation = (Annotation) it.next();
			index((T) annotation);
		}
	}

	public void index(T a) {
		final IndexEntry<T, K> comparisonEntry = new IndexEntry<>();
		Stream<K> indexTerms = indexTermGenerator.generateIndexTerms(a);
		indexTerms.forEach(t -> {
			comparisonEntry.term = t;
			IndexEntry<T, K> soughtEntry = index.floor(comparisonEntry);
			if (soughtEntry == null || soughtEntry.compareTo(comparisonEntry) != 0) {
				soughtEntry = new IndexEntry<T, K>(t, indexAnnotationCollectionSupplier.get());
				index.add(soughtEntry);
			}
			soughtEntry.annotations.add(a);
		});
	}

	public U search(Annotation a) {
		Stream<K> searchTerms = searchTermGenerator.generateIndexTerms(a);
		return search(searchTerms);
	}

	@SuppressWarnings("unchecked")
	public U search(Stream<K> searchTerms) {
		U hits = emptyResultCollection;
		final IndexEntry<T, K> comparisonEntry = new IndexEntry<>();
		int i = 0;
		for (Iterator<K> it = searchTerms.iterator(); it.hasNext();) {
			K t = it.next();
			comparisonEntry.term = t;
			IndexEntry<T, K> hit = index.floor(comparisonEntry);
			if (hit != null && hit.compareTo(comparisonEntry) == 0) {
				if (i == 0 && hit.annotations.getClass().equals(emptyResultCollection.getClass())) {
					hits = (U) hit.annotations;
				} else if (i == 1 && hit.annotations.getClass().equals(emptyResultCollection.getClass())) {
					U previousHits = hits;
					hits = resultCollectionSupplier.get();
					hits.addAll(previousHits);
					hits.addAll(hit.annotations);
				} else {
					hits.addAll(hit.annotations);
				}
				++i;
			}
		}

		return hits;
	}

	@SuppressWarnings("unchecked")
	public U search(K searchTerm) {
		U hits = emptyResultCollection;
		final IndexEntry<T, K> comparisonEntry = new IndexEntry<>();
		comparisonEntry.term = searchTerm;
		IndexEntry<T, K> hit = index.floor(comparisonEntry);
		if (hit != null && hit.compareTo(comparisonEntry) == 0) {
			if (hit.annotations.getClass().equals(emptyResultCollection.getClass()))
				hits = (U) hit.annotations;
			else {
				hits = resultCollectionSupplier.get();
				hits.addAll(hit.annotations);
			}
		}

		return hits;
	}

	public static class IndexEntry<T extends Annotation, K extends Comparable<K>>
			implements Comparable<IndexEntry<T, K>> {
		public K term;
		public Collection<T> annotations;

		private IndexEntry() {
		};

		public IndexEntry(K term, Collection<T> annotations) {
			this.term = term;
			this.annotations = annotations;
		}

		@Override
		public int compareTo(IndexEntry<T, K> o) {
			return term.compareTo(o.term);
		}
	}

	@FunctionalInterface
	public interface IndexTermGenerator<K extends Comparable<K>> {
		public Stream<K> generateIndexTerms(Annotation a);
	}

	public static class Comparators {
		public <T extends Annotation> Comparator<T> exactOffsetMatchComparator() {
			return (o1, o2) -> {

				if (o1.getBegin() == o2.getBegin() && o1.getEnd() == o2.getEnd())
					return 0;
				if (o1.getBegin() == o2.getBegin())
					return o1.getEnd() - o2.getEnd();
				return o1.getBegin() - o2.getBegin();
			};
		}

		public <T extends Annotation> Comparator<T> overlapComparator() {
			return (o1, o2) -> {
				int b1 = o1.getBegin();
				int e1 = o1.getEnd();
				int b2 = o2.getBegin();
				int e2 = o2.getEnd();

				if ((b1 <= b2) && (e1 >= e2)) {
					return 0;
				} else if ((b1 >= b2) && (e1 <= e2)) {
					return 0;
				} else if ((b1 < e2) && (e1 > e2)) {
					return 0;
				} else if ((b1 < b2) && (e1 > b2)) {
					return 0;
				}
				return b1 - b2;
			};
		}
	}

	public static class TermGenerators {
		public static IndexTermGenerator<String> nGramTermGenerator(int n) {
			return a -> {
				String text = a.getCoveredText();
				return IntStream.range(0, text.length()).mapToObj(i -> {
					if (i + n <= text.length())
						return text.substring(i, i + n);
					return null;
				}).filter(s -> s != null);
			};
		}

		public static IndexTermGenerator<String> prefixTermGenerator(int length) {
			return a -> {
				String text = a.getCoveredText();
				if (text.length() >= length)
					return Stream.of(text.substring(0, length));
				return Stream.empty();
			};
		}

		public static IndexTermGenerator<String> suffixTermGenerator(int length) {
			return a -> {
				String text = a.getCoveredText();
				if (text.length() >= length)
					return Stream.of(text.substring(text.length() - length, text.length()));
				return Stream.empty();
			};
		}
	}

}
